\chapter{Planning for \LTLf/\PLTL Goals}\label{ch:planning}
In this chapter, we will define a new approach to the problem of non-deterministic planning for extended temporal goals. In particular, we will give a solution to this problem reducing it to a \textit{fully observable non-deterministic} (\FOND) problem and taking advantage of our tool \LTLfToDFA, presented in Chapter \ref{ch:ltlf2dfa}. First of all, we will introduce the main idea and motivations supporting our approach. Then, we will give some preliminaries explaining the Planning Domain Definition Language (\PDDL) language and the \FOND planning problem formally. After that, we will illustrate our \FONDFOR approach with the encoding of temporal goals into a \PDDL domain and problem. Finally, we will present our practical implementation of the proposed solution.
\section{Idea and Motivations}\label{sec:plan-idea-motiv}
Planning for temporally extended goals with \textit{deterministic} actions has been well studied during the years starting from \citep{bacchus1998planning} and \citep{doherty2001talplanner}. Two main reasons why temporally extended goals have been considered over the classical goals, viewed as a desirable set of final states to be reached, are because they are not limited in what they can specify and they allows us to restrict the manner used by the plan to reach the goals. Indeed, temporal extended goals are fundamental for the specification of a collection of real-world planning problems. Yet, many of these real-world planning problems have a \textit{non-deterministic} behavior owing to unpredictable environmental conditions. However, planning for temporally extended goals with \textit{non-deterministic} actions is a more challenging problem and has been of increasingly interest only in recent years with \citep{camacho2017non, de2018automata}.

In this scenario, we have devised a solution to this problem that exploits the translation of a temporal formula to a \DFA, using \LTLfToDFA. In particular, our idea is the following: given a non-deterministic planning problem and a temporal formula, we first obtain the corresponding \DFA of the temporal formula through \LTLfToDFA, then, we encode such a \DFA into the non-deterministic planning domain. As a result, we have reduced the original problem to a classic \FOND planning problem. In other words, we compile extended temporal goals together with the original planning domain, specified in \PDDL, which is suitable for input to standard (\FOND) planners.
\section{Preliminaries}
In this section, we will give some basics on the \PDDL specification language for domains and problems of planning and a general formalization of \FOND planning.
\subsection{\PDDL}\label{sec:pddl}
As stated before, \PDDL is the acronym for Planning Domain Definition Language, which is the \textit{de-facto} standard language for representing ``classical'' planning tasks. A general planning task has the following components:
\begin{itemize}
\item Objects: elements in the world that are of our interest;
\item Predicates: objects properties that can be true or false;
\item Initial state: state of the world where we start;
\item Goal state: things we want to be true;
\item Action/Operator: rule that changes the state. 
\end{itemize}
Moreover, planning tasks are composed by two files: the \textit{domain} file where are defined predicates and actions and a \textit{problem} file where are defined objects, the initial state and the goal specification.
\subsubsection{The \textit{domain} file} 
The \textit{domain} definition gives each domain a name and specifies predicates and actions available in the domain. It might also specify types, constants and other things. A simple domain has the following format:
\begin{lstlisting}[language=PDDL, escapechar=£, label={code:pddl-domain}]
(define (domain DOMAIN_NAME)
  (:requirements [:strips] [:equality] [:typing] [:adl] ...)
  [(:types T1 T2 T3 T4 ...)]
  (:predicates (PREDICATE_1_NAME [?A1 ?A2 ... ?AN])
                (PREDICATE_2_NAME [?A1 ?A2 ... ?AN])
	       ...)

  (:action ACTION_1_NAME
    [:parameters (?P1 ?P2 ... ?PN)]
    [:precondition PRECOND_FORMULA]
    [:effect EFFECT_FORMULA]
   )
  (:action ACTION_2_NAME
    ...)
  ...)  
\end{lstlisting}
where \texttt{[]} indicates optional elements. To begin with, any \PDDL \textit{domain} definition must declare its expressivity requirements given after the \texttt{:requirements} key. The basic \PDDL expressivity is called \textsc{strips}\footnote{\textsc{strips} stands for STanford Research Institute Problem Solver, which is a formal language of inputs to the homonym automated planner developed in 1971.}, whereas a more complex one is the Action Description Language (\textsc{adl}), that extends \textsc{strips} in several ways, such as providing support for negative preconditions, disjunctive preconditions, quantifiers, conditional effects etc.. Nevertheless, many planners do not support full \textsc{adl} because creating plans efficiently is not trivial. Although the presence of this limitation, the \PDDL language allows us to use only some of the \textsc{adl} features. Furthermore, there are also other requirements often used that can be specified as \texttt{equality}, allowing the usage of the predicate \texttt{=} interpreted as equality, and \texttt{typing} allowing the typing of objects. As we will explain later in Section \ref{sec:planning-implementation}, our practical implementation supports, for now, only simple \textsc{adl}, namely conditional effects in domain's operators which do not have any nested subformula.

Secondly, there is the predicates definition after the \texttt{:predicates} key. Predicates may have zero or more parameters variables and they specify only the number of arguments that a predicate should have. Moreover, a predicate may also have typed parameters written as \texttt{?X -- TYPE\_OF\_X}.

Thirdly, there is a list of action definitions. An action is composed by the following items:
\begin{itemize}
\item \textit{parameters}: they stand for free variables and are represented with a preceding question mark \texttt{?};
\item \textit{precondition}: it tells when an action can be applied and, depending on given requirements, it could be differently defined (i.e. conjunctive formula, disjunctive formula, quantified formula, etc.);
\item \textit{effect}: it tells what changes in the state after having applied the action. As for the precondition, depending on given requirements, it could be differently defined (i.e. conjunctive formula, conditional formula, universally quantified formula, etc.)
\end{itemize}

In particular, in pure \textsc{strips} domains, the precondition formula can be one of the following:
\begin{itemize}
\item an atomic formula as \texttt{(PREDICATE\_NAME ARG1 ... ARG\_N)}
\item a conjunction of atomic formulas as \texttt{(and ATOM1 ... ATOM\_N)}
\end{itemize}
where arguments must either be parameters of the action or constants.

If the \textit{domain} uses the \texttt{:adl} or \texttt{:negated-precondition} an atomic formula could be expressed also as  \texttt{(not (PREDICATE\_NAME ARG1 ... ARG\_N))}. In addition, if the domain uses \texttt{:equality}, an atomic formula may also be of the form \texttt{(= ARG1 ARG2)}.

On the contrary, in \textsc{adl} domains, a precondition formula could be one of the following:
\begin{itemize}
\item a general negation as \texttt{(not CONDITION\_FORMULA)}
\item a conjunction of condition formulas as \texttt{(and CONDITION\_FORMULA1 ... \\CONDITION\_FORMULA\_N)}
\item a disjunction of condition formulas as \texttt{(or CONDITION\_FORMULA1 ... \\CONDITION\_FORMULA\_N)}
\item an implication as \texttt{(imply CONDITION\_FORMULA1 ... CONDITION\_FORMULA\_N)}
\item an implication as \texttt{(imply CONDITION\_FORMULA1 ... CONDITION\_FORMULA\_N)}
\item a universally quantified formula as \texttt{(forall (?V1 ?V2 ...) CONDITION\_FORMULA)}
\item an existentially quantified formula as \texttt{(exists (?V1 ?V2 ...)\\ CONDITION\_FORMULA)}
\end{itemize}

The same division can be carried out with effects formulas. Specifically, in pure \textsc{strips} domains, the precondition formula can be one of the following:
\begin{itemize}
\item an added atom as \texttt{(PREDICATE\_NAME ARG1 ... ARG\_N)}
\item a deleted atom as \texttt{(not (PREDICATE\_NAME ARG1 ... ARG\_N))}
\item a conjunction of effects as \texttt{(and ATOM1 ... ATOM\_N)}
\end{itemize}
On the other hand, in an \textsc{adl} domains, an effect formula can be expressed as:
\begin{itemize}
\item a conditional effect as \texttt{(when CONDITION\_FORMULA EFFECT\_FORMULA)}, where the \texttt{EFFECT\_FORMULA} is occur only if the \texttt{CONDITION\_FORMULA} holds true. A conditional effect can be placed within quantification formulas.
\item a universally quantified formula as \texttt{(forall (?V1 ?V2 ...) EFFECT\_FORMULA)}
\end{itemize}

As last remark that we will deepen later in Section \ref{sec:fond}, when the \PDDL \textit{domain} has \textit{non-deterministic} actions, the effect formula of those actions expresses the non-determinism with the keyword \texttt{oneof} as \texttt{(oneof (EFFECT\_FORMULA\_1) ... \\ (EFFECT\_FORMULA\_N)}.

In the following, we show a simple example of \PDDL \textit{domain}.

\begin{example}\label{ex:pddl-domain}
A simple \PDDL \textit{domain} the Tower of Hanoi game. This game consists of three rods and $n$ disks of different size, which can slide into any rods. At the beginning, disks are arranged in a neat stack in ascending order of size on a rod, the smallest on the top. The goal of the game is to move the whole stack to another rod, following three rules:
\begin{itemize}
\item one disk at a time can be moved;
\item a disk can be moved only if it is the uppermost disk on a stack;
\item no disk can be placed on top of a smaller disk.
\end{itemize}
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (domain hanoi) ;comment£\label{line:domain-name}£
  (:requirements :strips :negative-preconditions :equality)£\label{line:requirements}£
  (:predicates (clear ?x) (on ?x ?y) (smaller ?x ?y) )£\label{line:predicates}£
  (:action move
    :parameters (?disc ?from ?to)£\label{line:parameters}£
    :precondition (and£\label{line:precond}£
       (smaller ?disc ?to) (smaller ?disc ?from)
       (on ?disc ?from)
       (clear ?disc) (clear ?to)
       (not (= ?from ?to))
    )
    :effect (and£\label{line:effects}£
      (clear ?from)
      (on ?disc ?to)
      (not (on ?disc ?from))
      (not (clear ?to))
    )
  )
)
\end{lstlisting}
The \PDDL \textit{domain} file of the Tower of Hanoi is quite simple. Indeed, it consists of only one action (\texttt{move}) and only a few predicates. Firstly, the name given to this \textit{domain} is \texttt{hanoi}. Then, there have been specified requirements as \texttt{:strips}, \texttt{:negative-preconditions} and \texttt{:equality}. After that, at line \ref{line:predicates}, there is the definition of all predicates involved in the \PDDL \textit{domain}. In particular, there are three predicates to describe if the top of a disk is \texttt{clear}, which disk is \texttt{on} top of another and, finally, which disk is \texttt{smaller} than another. Finally, there is the \texttt{move} action declaration with its parameters, its precondition formula and its effect formula.
\end{example}
\subsubsection{The \textit{problem} file} 
After having examined how a \PDDL \textit{domain} is defined, we can see the formulation of a \PDDL \textit{problem}. A \PDDL \textit{problem} is what a planner tries to solve. The \textit{problem} file has the following format:
\begin{lstlisting}[language=PDDL, escapechar=£, label={code:pddl-domain}]
(define (problem PROBLEM_NAME)
  (:domain DOMAIN_NAME)
  (:objects OBJ1 OBJ2 ... OBJ_N)
  (:init ATOM1 ATOM2 ... ATOM_N)
  (:goal CONDITION_FORMULA)
  )
\end{lstlisting}
At a first glance, we can notice that the \textit{problem} definition includes the specification of the domain to which it is related. Indeed, every problem is defined with respect to a precise \textit{domain}. Then, there is the object list which could be typed or untyped. After that, there are the initial and goal specification, respectively. The former defines what is true at the beginning of the planning task and it consists of ground atoms, namely predicates instantiated with previously defined objects. Finally, the goal description represents the formula, consisting of instantiated predicates, that we would like to achieve and obtain as a final state.
In the following, we show a simple example of \PDDL \textit{problem}.

\begin{example}
In this example, we show a possible \PDDL \textit{problem} for the Tower of Hanoi game for which we have shown the \textit{domain} in the Example \ref{ex:pddl-domain}.
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (problem hanoi-prob)
  (:domain hanoi)
  (:objects rod1 rod2 rod3 d1 d2 d3)£\label{line:objs-prob}£
  (:init 
     (smaller d1 rod1) (smaller d2 rod1) (smaller d3 rod1)
     (smaller d1 rod2) (smaller d2 rod2) (smaller d3 rod2)
     (smaller d1 rod3) (smaller d2 rod3) (smaller d3 rod3)
     (smaller d2 d1) (smaller d3 d1) (smaller d3 d2)
     (clear rod2) (clear rod3) (clear d1)
     (on d3 rod1) (on d2 d3) (on d1 d2))
  (:goal (and (on d3 rod3) (on d2 d3) (on d1 d2)))
)
\end{lstlisting}
At line \ref{line:objs-prob}, we have three rods and three disks. At the beginning, all instantiated predicates that are true are mentioned. If a predicate is not mentioned, it is considered to be false. In the initial situation there have been specified all possible movements with the \texttt{smaller} predicate, the disks are one on top of the other in ascending order on \texttt{rod1} whereas the other two rods are \texttt{clear}. In addition, the goal description is a conjuctive formula requiring disks on a stack on the \texttt{rod3}.
\end{example}

Once both \PDDL \textit{domain} and a \textit{problem} are specified, they are given as input to planners.
\subsection{Fully Observable Non Deterministic Planning}\label{sec:fond}
In this Section, we formally define what \textit{Fully Observable Non Deterministic Planning} (\FOND) is giving some notions and definitions. Initially, we recall some concepts of ``classical'' planning while assuming the reader to be acquainted with basics of planning.

Given a \PDDL specification with a \textit{domain} and its corresponding \textit{problem}, we would like to solve this specification in order to find a sequence of actions such that the goal formula holds true at the end of the execution. A \textit{plan} is exactly that sequence of actions which leads the agent to achieve the goal starting from the initial state. Formally, we give the following definition.

\begin{definition}\label{def:classic-planning}
A planning problem is defined as a tuple $\P = \tup{\Sigma, s_0, g}$, where:
\begin{itemize}
\item $\Sigma$ is the state-transition system;
\item $s_0$ is the initial state;
\item $g$ is the goal state.
\end{itemize}
\end{definition}

\noindent Given the above Definition \ref{def:classic-planning}, we can formally define what a plan is.

\begin{definition}\label{def:plan}
A \textit{plan} is any sequence of actions $\sigma = \tup{a_1,a_2,\dots, a_n}$ such that each $a_i$ is a ground instance of an operator defined in the domain description.
\end{definition}

\noindent Moreover, we have that:

\begin{definition}\label{def:plan-sol}
A \textit{plan} is a solution for $\P = \tup{\Sigma, s_0, g}$, if it is executable and achieves $g$.
\end{definition}

Furthermore, a ``classical'' planning problem, just defined, is given under the assumptions of \textit{fully observability} and \textit{determinism}. In particular, the former means that the agent can always see the entire state of the environment whereas the latter means that the execution of an action is certain, namely any action that the agent takes uniquely determines its outcome.

Unlike the ``classical'' planning approach, in this thesis we focus on \textit{Fully Observable Non Deterministic} (\FOND) planning. Indeed, we continue relying on the \textit{fully observability}, but loosing the \textit{determinism}. In other words, in \FOND planning we have the uncertainty on the outcome of an action execution. As anticipated in Section \ref{sec:pddl}, the uncertainty of the outcome of an operator execution is syntactically expressed, in \PDDL, with the keyword \texttt{oneof}. To better capture this concept, we give the following example.

\begin{example}
Here, we show as example the \texttt{put-on-block} operator of the \FOND version of the well-known blocksworld \PDDL \textit{domain}.
\begin{lstlisting}[language=PDDL, escapechar=£]
(:action put-on-block
  :parameters (?b1 ?b2 - block)
  :precondition (and (holding ?b1) (clear ?b2))
  :effect (oneof (and (on ?b1 ?b2) (emptyhand) (clear ?b1) £\label{line:oneof}£
                 (not (holding ?b1)) (not (clear ?b2)))
                 (and (on-table ?b1) (emptyhand) (clear ?b1) 
                 (not (holding ?b1)))
          )
)
\end{lstlisting}
The effect of the \texttt{put-on-block} is non deterministic. Specifically, the action is executed every time the agent is holding a block and another block is clear on the top. The effect can be either that the block is put on top of the other block or that the block is put on table. This has to be intended as an aleatory event. Indeed, the agent does not control the operator execution result.
\end{example}

Additionally, a \textit{non-deterministic} action $a$ with effect $oneof(E_1,\dots,E_n)$ can be intended as a set of \textit{deterministic} actions $b_1,\dots,b_n$, sharing the same precondition of $a$, but with effects $E_1,\dots,E_n$, respectively. Hence, the application of action $a$ turns out in the application of one of the actions $b_i$, chosen non-deterministically.

At this point, we can formally define the \FOND planning. Following \citep{ghallab2004automated} and \citep{geffner2013concise}, we give the following definition:
\begin{definition}
A \textit{non-deterministic domain} is a tuple $\D = \tup{2^\F, A, s_0, \varrho, \alpha}$ where:
\begin{itemize}
\item $\F$ is a set of \textit{fluents} (atomic propositions);
\item $A$ is a set of \textit{actions} (atomic symbols);
\item $2^\F$ is the set of states;
\item $s_0$ is the initial state (initial assignment to fluents);
\item $\alpha(s) \subseteq A$ represents \textit{action preconditions};
\item $(s, a, s') \in \varrho$ with $a \in \alpha(s)$ represents \textit{action effects} (including frame assumptions).
\end{itemize}
\end{definition}
\noindent Such domain $\D$ is assumed to be represented compactly (e.g. in \PDDL), therefore, considering the \textit{size} of the domain as the cardinality of $\F$. Intuitively, the evolution of a non-deterministic domain is as follows: from a given state $s$, the agent chooses what action $a \in \alpha(s)$ to execute, then, the environment chooses a \textit{successor state} $s'$ with $(s,a,s') \in \varrho$. To this extent, planning can also be seen as a \textit{game} between two players: the agent tries to force eventually reaching the goal no matter how the environment behaves.
Moreover, the agent can execute an action having the knowledge of all history of states so far.

Now, we can define the meaning of solving a \FOND planning problem on $\D$. A \textit{trace} of $\D$ is a finite or infinite sequence $s_0,a_0,s_1,a_1, \dots$ where $s_0$ is the initial state, $a_i \in \alpha(s_i)$ and $s_{i+1} \in \varrho(s_i,a_i)$ for each $s_i,a_i$ in the trace.

Solutions to a \FOND problem $\P$ are called \textit{strategies} (or \textit{policies}). A \textit{strategy} $\trace$ is defined as follows:
\begin{definition}\label{def:policy}
Given a \FOND problem $\P$, a \textit{strategy} $\trace$ for $\P$ is a partial function defined as:
\begin{equation}
\trace: (2^\F)^+ \rightarrow A
\end{equation}
such that for every $u \in (2^\F)^+$, if $\trace(u)$ is defined, then $\trace(u) \in \alpha(last(u))$, namely it selects applicable actions, whereas, if $\trace(u)$ is undefined, then $\trace(u) = \bot$.
\end{definition}
\noindent A trace $\tau$ is \textit{generated} by $\trace$ (often called $\trace$-trace) if the following holds:
\begin{itemize}
\item if $s_0,a_0,\dots,s_i,a_i$ is a prefix of $\tau$, then $\trace(s_0,s_1,\dots,s_i) = a_i$;
\item if $\tau$ is finite, i.e. $\tau = s_0,a_0,\dots,a_{n-1},s_n$, then $\trace(s_0,s_1,\dots,s_i) = \bot$.
\end{itemize}

For \FOND planning problems, in \citep{cimatti2003weak}, are defined different classes of solutions. Here we examine only two of them, namely \textit{strong solution} and \textit{strong cyclic solutions}. In the following, we give their formal definitions.

\begin{definition}\label{def:strong-sol}
A \textit{strong solution} is a strategy that is guaranteed to achieve the goal regardless of non-determinism.
\end{definition}

\begin{definition}\label{def:strong-cyc-sol}
\textit{Strong cyclic solutions} guarantee goal reachability only under the assumption of \textit{fairness}. In the presence of \textit{fairness} it is supposed that all action outcomes, in a given state, would occur infinitely often. 
\end{definition}
Obviously, \textit{strong cyclic solutions} are less restrictive than a \textit{strong solution}.
Indeed, as the name suggests, a strong cyclic solution may revisit states. However, in this thesis we will focus only on searching \textit{strong solutions}. As final remark, when searching for a strong solution to a \FOND problem we refer to \FONDS.

In the next Section, we will generalize the concept of solving \FOND planning problems with extended temporal goals, describing the step by step encoding process of those temporal goals in the \FOND domain, written in \PDDL.
\section{The \FONDFOR approach}\label{sec:fond-plan-appr}
As written in Section \ref{sec:plan-idea-motiv}, planning with extended temporal goals has been considered over the representation of goals in classical planning to capture a richer class of plans where restrictions on the whole sequence of states must be satisfied as well. In particular, differently from classical planning, where the goal description can only be expressed as a propositional formula, in planning for extended temporal goals the goal description may have the same expressive power of the temporal logic in which the goal is specified. This enlarges the general view about planning. In other words, extended temporal goals specify desirable sequences of states and a plan exists if its execution yields one of these desirable sequences \citep{bacchus1998planning}.

In this thesis, we propose a new approach, called \FONDFOR, that uses \LTLf and \PLTL formalisms as temporal logics for expressing extended goals.
To better understand the powerful of planning with extended temporal goals we give the following example.

\begin{example}\label{ex:pla-temp-simple}
Considering the well known \texttt{triangle tireworld} \FOND planning task. The objective is to drive from one location to another, however while driving a tire may be going flat. If there is a spare tire in the location of the car, then the car can use it to fix the flat tire. The task in depicted in Figure \ref{fig:ttireworld-task}, where there are locations arranged as a triangle, arrows representing roads and circles meaning that in a location there is a spare tire. 

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{images/ttireworld-task}
\caption{A possible Triangle Tireworld task. Locations marked with a circle have a spare tire, arrows represent possible directions} 
\label{fig:ttireworld-task}
\end{figure}

A possible classical goal can be $G = vehicleAt(l31)$, namely a propositional formula saying something only about what have to be true at the end of the execution. In the case of $G$, we exclusively require that the vehicle should be in location $l31$.

On the contrary, a goal specification expressed with temporal formalism such as \PLTL could be $\varphi = vehicleAt(l13) \lAND \Once(vehicleAt(l23))$. Such a specification requires to reach position $l13$, imposing the passage through position $l23$ before reaching the goal.
\end{example}

Planning for \LTLf and \PLTL goals slightly changes the definitions given in Section \ref{sec:fond}. In the following, we give the modified definitions of the concepts seen before.

\begin{definition}\label{def:strong-sol-extend}
Given a domain $\D$ and an \LTLf/\PLTL formula $\varphi$ over atoms $\F \cup \mathcal{A}$, a strategy $\trace$ is a \textit{strong solution} to $\D$ for goal $\varphi$, if every $\trace$-trace is finite and satisfies $\varphi$.
\end{definition}

About complexity of \FONDS, we have the following Theorems.

\begin{theorem}\citep{de2018automata}
\label{th:fond-ltlf-complex}
Solving \FONDS for \LTLf goals is:
\begin{itemize}
\item \EXPTIME-complete in the size of the domain;
\item \TWOEXPTIME-complete in the size of the goal.
\end{itemize}
\end{theorem}

Furthermore, if the goal has the form of $\Diamond G$, i.e. is a reachability goal, the cost with respect to the goal becomes polynomial because it is just a propositional evaluation. If for a given \LTLf goal the determinization step does not cause a state explosion,  the complexity with respect to the goal is \EXPTIME. 
On the contrary, if $G$ is a \PLTL formula, from results in \cite{de2018automata}, we can only say that the complexity is \TWOEXPTIME in the size of the goal.
%\begin{theorem}
%\label{th:fond-pltl-complex}
%Solving \FONDS for \PLTL goals is:
%\begin{itemize}
%\item \EXPTIME-complete in the size of the domain;
%\item \TWOEXPTIME-complete in the size of the goal.
%\end{itemize}
%\end{theorem}
Even though we remark that the investigation on planning for \PLTL goals may have a computational advantage since \PLTL formulas can be reduced to \DFA in single exponential time (vs. double-exponential time of \LTLf formulas) \citep{chandra1981acm}, computing the hardness is not obvious because we should evaluate the formula only after the $\Diamond$ operator.

\subsection{Idea}
Our \FONDFOR approach works as follows: given a non-deterministic planning domain $\D$, an initial state $s_0$ and an \LTLf or \PLTL goal formula $\varphi$ (whose symbols are ground predicates), we first obtain the corresponding \DFA of the temporal formula through \LTLfToDFA, then, we encode such a \DFA into the non-deterministic planning domain $\D$. As a result, we will have a new domain $\D'$ and a new problem $P'$ that can be considered and solved as a classical \FOND planning problem. 

The new approach, carried out in this thesis, stems from the research in \cite{de2018automata}, that, basically, proposes automata-theoretic foundations of \FOND planning for \LTLf goals. In particular, they compute the cartesian product between the \DFA corresponding to the domain $\D$ ($\automaton_\D$) and the \DFA corresponding to $\varphi$ ($\automaton_\varphi$), thus, solving a \DFA game on $\automaton_\D \times \automaton_\varphi$, i.e. find, if exists, a trace accepted by $\automaton_\D \times \automaton_\varphi$. Moreover, an important consideration is that the resulting automaton $\automaton_\D \times \automaton_\varphi$ will read both the action and its effect, as shown, for instance, in Figure \ref{fig:dfa-game}.

However, unlike what has been done in \cite{de2018automata}, we split transitions containing the action and its effect in order to have them separately. The reason for this separation is that having both the action and its effect on the same transition is not suitable on a practical perspective. Hence, we have devised a solution in which we run $\automaton_\D$ and $\automaton_\varphi$ separately, but combining them into a single unique transition system. To achieve this, we move $\automaton_\D$ and $\automaton_\varphi$ alternatively by introducing an additional predicate, which we will call \texttt{turnDomain}, that is true when we should move $\automaton_\D$ and is false when we should move $\automaton_\varphi$. In the following, we give an example to better understand the solution put in place in this thesis.

\begin{example}\label{ex:yale-scenario}
Let us consider the simplified version of the classical Yale shooting domain \citep{hanks1986default} as in \cite{de2018automata}, where we have that the turkey is either alive or not and the actions are shoot and wait with the obvious effects, but with a gun that can be faulty. Specifically, shooting with a (supposedly) working gun can either end in killing the turkey or in the turkey staying alive and the discovery that the gun is not working properly. On the other hand, shooting (with care) with a gun that does not work properly makes it work and kills the turkey. The cartesian product $\automaton_\D \times \automaton_\varphi$ with $\varphi = \Diamond\lnot a$ is as follows:

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{images/cartesian-prod}
\caption{The \DFA corresponding to $\automaton_\D \times \automaton_\varphi$. Symbol \texttt{a} stands for \textit{alive} and \texttt{w} for \textit{working}} 
\label{fig:dfa-game}
\end{figure}

\noindent As we can see in Figure \ref{fig:dfa-game}, each transition reads both the action and its effect. This is not suitable for a practical implementation. Thus, we do not perform the cartesian product between the two automata. On the contrast, we build a transition system as in Figure \ref{fig:yale-our-sol}.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{images/yale-our-sol}
\caption{The new transition system corresponding to the Yale shooting domain. Symbol \texttt{a} stands for \textit{alive}, \texttt{w} for \textit{working} and \texttt{t} for \textit{turnDomain}} 
\label{fig:yale-our-sol}
\end{figure}
\end{example}

The transition system, shown in Figure \ref{fig:yale-our-sol}, expresses the new domain $\D'$ that has a perfect alternation of transitions. In particular, actions of the initial domain $\D$ alternates with a special action, that we called \texttt{trans}, representing the movement done by $\automaton_\varphi$. Moreover, it is important to notice the usage of the added predicate \texttt{turnDomain} allowing us to alternate between general actions and the new action \texttt{trans}.

In the next Section, we will explain how the new domain $\D'$ and the new problem $\P'$ can be written in \PDDL by showing the encoding of \LTLf/\PLTL goals in \PDDL.

\subsection{Encoding of \LTLf/\PLTL goals in \PDDL}\label{sec:encoding-goals}
In this Section, we describe the process of obtaining the new domain $\D'$ and the new problem $\P'$, both specified in \PDDL. The original \PDDL domain $\D$ and the associated original problem $\P$ change when introducing \LTLf/\PLTL goals. In particular, what changes is the way we encode our \LTLf/\PLTL formula in \PDDL. Firstly, we employ our \LTLfToDFA tool to convert the given goal formula $\varphi$ into the corresponding \DFA. Then, we encode, in a specific way, the resulting \DFA automaton in \PDDL modifying the original domain $\D$ and problem $\P$.

\subsubsection*{Translation of \DFAs to \PDDL in Domain $\D$}
In order to explain the translation technique of a \DFA to \PDDL, we assume to already have the \DFA generated by \LTLfToDFA. We recall that such a \DFA is formally defined as follows:
\begin{definition}\label{plan:dfa}
A \DFA is a tuple $\automaton = \tup{\Sigma, Q, q_0 , \delta, F}$, where:
\begin{itemize}		
\item $\Sigma = \{ a_0,a_1,\dots,a_n \}$ is a finite set of symbols;
\item $Q = \{ q_0,q_1,\dots,q_m \}$ is the finite set of states;
\item $q_0 \in Q$ is the initial state;
\item $\delta: Q \times \Sigma \rightarrow Q$ is the transition function;
\item $F \subseteq Q$ is the set of final states;
\end{itemize}
\end{definition}
Specifically, since the automaton $\automaton$ corresponds to the goal formula $\varphi$, which has grounded predicates as symbols, we can represent them as $\{a_0(o_0,\dots,o_j),\dots, a_n(o_0,\dots,o_w)\}$, where $o_0,\dots,o_k \in \O$ and $0 \leq j,w \leq k$ represents objects of the domain $\D$. To capture the general representation of $\varphi$ in $\D$, we have to modify $\automaton$ to $\automaton'$ performing a transformation explained below. We give the following definitions.

\begin{definition}\label{plan:automaton-prime}
$\automaton'$ is a tuple $\automaton' = \tup{\Sigma', Q', q'_0 , \delta', F'}$, where:
\begin{itemize}		
\item $\Sigma' = \{ a'_0,a'_1,\dots,a'_n \}$ is a finite set of symbols;
\item $Q' = \{ q'_0,q'_1,\dots,q'_m \}$ is the finite set of states;
\item $q'_0 \in Q$ is the initial state;
\item $\delta': Q' \times \Sigma' \rightarrow Q'$ is the transition function;
\item $F' \subseteq Q'$ is the set of final states;
\end{itemize}
\end{definition}

\begin{definition}\label{plan:mapfunc}
Given the set of \DFA symbols $\Sigma$, we define a mapping function $f$ as follows:
\begin{equation}
f: \O \rightarrow \V
\end{equation}
where $\O$ is the set of objects $\{o_0,\dots,o_k\}$ and $\V$ is a set of variables $\{x_0,\dots,x_k\}$
\end{definition}

The transformation from $\automaton$ and $\automaton'$ is carried out with the mapping function $f$ as follows:
\begin{itemize}
\item $\Sigma' = \{ a'_0,\dots,a'_n \}$, where $a'_i \doteq a_i(x_0,\dots,x_j)$ and $x_0,\dots,x_j \subseteq \V$;
\item $Q' = \{ q'_0,\dots,q'_m \}$, where $q'_i \doteq q_i(x_0\dots, x_k)$.
\end{itemize}
Then, $q'_0, \delta' \text{ and } F'$ are modified accordingly.

Once the transformation is done, we have obtained a parametric \DFA which is a general representation with respect to the original one. After that, for representing the \DFA transitions in the domain $\D$, we should encode the new \textit{transition function} $\delta'$ into \PDDL. To this extent, the $\delta'$ function is represented as a new \PDDL operator, called \texttt{trans} having  these properties:

\begin{itemize}
\item all variables in $\V$ are parameters;
\item the negation of the \texttt{turnDomain} predicate is a precondition;
\item effects represent the $\delta'$ function.
\end{itemize}
Moreover, effects are expressed as conditional effects. The general encoding would be as follows:
\begin{lstlisting}[escapechar=£]
Action £\texttt{trans}£:
  parameters: £$(x_0, \dots, x_k)$, where $x_i \in \V$£
  preconditions: £$\lnot turnDomain$£
  effects: £when $(q_i(x_0, \dots, x_k) \lAND a'_j)$ then $(\delta'(q'_i, a'_j)=q''_i(x_0, \dots, x_k) \lAND (\lnot q, \forall q \in Q \text{ s.t. } q \neq q''_i) \lAND turnDomain),\; \forall i,j: 0\leq i \leq m, 0\leq j \leq n$£
\end{lstlisting}

Additionally, in \PDDL, especially in the effect formula of a conditional effect, we should specify that if the automaton is in a state, it is not in other states. This is captured by adding the negation of all other automaton states. In the following, we give an example showing the translation of \DFAs to \PDDL step-by-step.
%At this point, after the construction of the \texttt{trans} operator, we add it to the domain $\D$, thus obtaining the new domain $\D'$. As a result, the representation of the \DFA, associated to $\varphi(x_1,x_2,\dots,x_n)$, is parametric, namely both states and actions depend on variables as for the automaton in Figure \ref{fig:dfa-parametric}.

\begin{example}\label{ex:param-formula}
Let us consider the goal formula $\varphi = \Diamond(on(d3,rod3))$ for the Tower of Hanoi planning problem. The predicate \texttt{on} is instantiated on objects \texttt{d3} and \texttt{rod3}. By applying the mapping function $f$ we have the corresponding variables and $\varphi$ becomes $\varphi(x_1,x_2) = \Diamond(on(x_1,x_2))$, where we know that $x_1 = f(d_3)$ and  $x_2 = f(rod_3)$. In this case, the modified \DFA $\automaton'$ is depicted in Figure \ref{fig:dfa-parametric}.
\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{images/automa-param}
\caption{The parametric \DFA corresponding to $\varphi(x_1,x_2) = \Diamond(on(x_1,x_2))$} 
\label{fig:dfa-parametric}
\end{figure}
%At this point, we can explain how we build the new operator \texttt{trans}. Since this operator has been introduced to simulate moves of the automaton related to the goal formula, the operator will have:
%\begin{itemize}
%\item variables as parameters;
%\item the negation of the \texttt{turnDomain} predicate as precondition;
%\item transitions encoded as conditional effects as effect.
%\end{itemize}
%We give the following example:
At this point, consider the new \DFA, the \texttt{trans} operator built from that automaton is the following:
\begin{lstlisting}[language=PDDL, escapechar=£]
(:action trans
  :parameters (?x1 ?x2)
  :precondition (not (turnDomain))
  :effect (and (when (and (q1 ?x1 ?x2) (not (on ?x1 ?x2)))
              (and (q1 ?x1 ?x2) (not (q2 ?x1 ?x2)) (turnDomain))
          (when (or (and (q1 ?x1 ?x2) (on ?x1 ?x2)) (q2 ?x1 ?x2))£\label{line:cond-eff-ex}£
              (and (q2 ?x1 ?x2) (not (q1 ?x1 ?x2)) (turnDomain))
  )
)
\end{lstlisting}
\end{example}

As just shown in Example \ref{ex:param-formula}, transitions, with source state and destination state, are encoded as conditional effects, where the condition formula includes source state and formula symbols whereas the effect formula includes the destination state, the negation of all other states and \texttt{turnDomain}. Moreover, in order to get a compact encoding of \texttt{trans} effects, conditional effects are brought together by destination state as happens, for instance, at line \ref{line:cond-eff-ex}.

After the \texttt{trans} operator has been built, we change $\D$ as follows:
\begin{enumerate}
\item $\forall a \in A$: add \texttt{turnDomain} to $\alpha(s)$, i.e add \texttt{turnDomain} predicate to all actions precondition $\alpha(s)$;
\item $\forall a \in A$: add \texttt{(not (turnDomain))} to $(s,a,s') \in \varrho$ with $a \in \alpha(s)$, i.e add negated \texttt{turnDomain} to all actions effects $(s,a,s')$;
\item add \texttt{trans} operator;
\item $\forall q' \in Q'$: add $q'$ to predicates definition of $\D$, i.e. add all automaton state predicates to the domain predicates definition.
\end{enumerate}

\noindent We have thus obtained the new domain $\D'$. In the following, we show an example.

\begin{example}\label{ex:new-dom}
Let consider again the Triangle Tireworld scenario. The original \PDDL domain is:
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (domain triangle-tire)
  (:requirements :typing :strips :non-deterministic)
  (:types location)
  (:predicates (vehicle-at ?loc - location)
	       (spare-in ?loc - location)
	       (road ?from - location ?to - location)
	       (not-flattire))
  (:action move-car
    :parameters (?from - location ?to - location)
    :precondition (and (vehicle-at ?from) (road ?from ?to) 
      (not-flattire))
    :effect (oneof (and (vehicle-at ?to) (not (vehicle-at ?from)))
	  (and (vehicle-at ?to) (not (vehicle-at ?from)) 
	  (not (not-flattire))))
   )
  (:action changetire
    :parameters (?loc - location)
    :precondition (and (spare-in ?loc) (vehicle-at ?loc))
    :effect (and (not (spare-in ?loc)) (not-flattire))
   )
)
\end{lstlisting}
Now, consider a simple \LTLf formula $\varphi = \Diamond vehicleAt(l13)$. It requires that eventually the vehicle will be in location $l13$. The parametric \DFA associated to $\varphi(x)$ is depicted in Figure \ref{fig:dfa-parametric2}.
\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{images/automa-param2}
\caption{The parametric \DFA corresponding to $\varphi(x) = \Diamond(vehicleAt(x))$} 
\label{fig:dfa-parametric2}
\end{figure}

Considering the \DFA in Figure \ref{fig:dfa-parametric2}, the \texttt{trans} operator built from that automaton is the following:
\begin{lstlisting}[language=PDDL, escapechar=£]
(:action trans
  :parameters (?x - location)
  :precondition (not (turnDomain))
  :effect (and (when (and (q1 ?x) (not (vehicle-at ?x)))
              (and (q1 ?x) (not (q2 ?x)) (turnDomain))
          (when (or (and (q1 ?x) (vehicle-at ?x)) (q2 ?x))
              (and (q2 ?x) (not (q1 ?x)) (turnDomain))
  )
)
\end{lstlisting}

Finally, putting together all pieces and carrying out changes described above, we obtain the new domain $\D'$ as follows:

\begin{lstlisting}[language=PDDL, escapechar=£]
(define (domain triangle-tire)
  (:requirements :typing :strips :non-deterministic)
  (:types location)
  (:predicates (vehicle-at ?loc - location)
	       (spare-in ?loc - location)
	       (road ?from - location ?to - location)
	       (not-flattire)
	       (q1 ?x - location)
	       (q2 ?x - location)
	       (turnDomain))
  (:action move-car
    :parameters (?from - location ?to - location)
    :precondition (and (vehicle-at ?from) (road ?from ?to) 
      (not-flattire) (turnDomain))
    :effect (oneof (and (vehicle-at ?to) (not (vehicle-at ?from))
      (not (turnDomain)))
	  (and (vehicle-at ?to) (not (vehicle-at ?from)) 
	  (not (not-flattire)) (not (turnDomain))))
   )
  (:action changetire
    :parameters (?loc - location)
    :precondition (and (spare-in ?loc) (vehicle-at ?loc) 
      (turnDomain))
    :effect (and (not (spare-in ?loc)) (not-flattire)
      (not (turnDomain)))
   )
  (:action trans
    :parameters (?x - location)
    :precondition (not (turnDomain))
    :effect (and (when (and (q1 ?x) (not (vehicle-at ?x)))
              (and (q1 ?x) (not (q2 ?x)) (turnDomain))
          (when (or (and (q1 ?x) (vehicle-at ?x)) (q2 ?x))
              (and (q2 ?x) (not (q1 ?x)) (turnDomain)))
  )   
)
\end{lstlisting}
\end{example}

\subsubsection*{Change in Problem $\P$}
Concerning the planning problem $\P$, we completely discard the goal specification, whereas the initial state description is slightly modified. Moreover, the problem name, the associated domain name and all defined objects remain unchanged. We have to modify both the initial state and the goal state specifications to make them compliant with $\D'$, containing all changes introduced in the planning domain $\D$. To this extent, we formally define the new initial state as follows:
\begin{equation}
\text{Init: } s_0 \lAND \text{\texttt{turnDomain}} \lAND \hat{q}'_0
\end{equation}
where $\hat{q}'_0 \doteq q_0(f^{-1}(x_0),\dots,f^{-1}(x_k)) = q_0(o_0,\dots,o_k)$. In other words, we put together the original initial specification $s_0$, the new predicate \texttt{turnDomain}, meaning that it is $true$ at the beginning, and the initial state of the automaton instantiated on the objects of interest, i.e. those specified in the \LTLf/\PLTL formula $\varphi$. 

On the other hand, the goal description is built from scratch as follows:
\begin{equation}
\text{Goal: } \text{\texttt{turnDomain}} \lAND (\bigvee_{\hat{q}' \in F} \hat{q}')
\end{equation}
where $\hat{q}' \doteq q(f^{-1}(x_0),\dots,f^{-1}(x_k)) = q(o_0,\dots,o_k)$. In other words, we place  together the \texttt{turnDomain} predicate, meaning that it must be $true$ at the end of the execution, and the final state(s) of the automaton always instantiated on the objects of interest. Here, it is important to notice that if the automaton has two or more final states, they should be put in disjunction.

We can give the following example.

\begin{example}\label{ex:new-prob}
Let consider again the Triangle Tireworld scenario, shown in the Example \ref{ex:new-dom}. The original \PDDL domain is:
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (problem triangle-tire-1)
  (:domain triangle-tire)
  (:objects l11 l12 l13 l21 l22 l23 l31 l32 l33 - location)
  (:init (vehicle-at l11)
    (road l11 l12) (road l12 l13) (road l11 l21) (road l12 l22)
    (road l21 l12) (road l22 l13) (road l21 l31) (road l31 l22)
    (spare-in l21) (spare-in l22) (spare-in l31)
    (not-flattire))
  (:goal (vehicle-at l13))
)
\end{lstlisting}
Now, considering the same \LTLf formula $\varphi = \Diamond vehicleAt(l13)$, the object of interest is $l13$. Hence, we should evaluate our automaton states as $q_1(l13)$ and $q_2(l13)$.

Finally, putting together all pieces and carrying out changes described above, we obtain the new problem $\P'$ as follows:

\begin{lstlisting}[language=PDDL, escapechar=£]
(define (problem triangle-tire-1)
  (:domain triangle-tire)
  (:objects l11 l12 l13 l21 l22 l23 l31 l32 l33 - location)
  (:init (vehicle-at l11)
    (road l11 l12) (road l12 l13) (road l11 l21) (road l12 l22)
    (road l21 l12) (road l22 l13) (road l21 l31) (road l31 l22)
    (spare-in l21) (spare-in l22) (spare-in l31)
    (not-flattire) (turnDomain) (q1 l13))
  (:goal (and (turnDomain) (q2 l13)))
)
\end{lstlisting}
As a remark, we will refer to the new goal specification as $\G'$.
\end{example}

Having examined the encoding of \LTLf/\PLTL goal formulas in \PDDL, the resulting planning domain $\D'$ and problem $\P'$ represent a ``classical'' planning specification. In the next Section, we will see how we obtain a strong policy giving $\D'$ and $\P'$.

\subsection{\FOND Planners}
In this Section, we talk about the state-of-art \FOND planners and how they are employed within this thesis.

To begin with, thanks to our encoding process, we have reduced the problem of \FOND planning for \LTLf/\PLTL goals to a ``classical'' \FOND planning, which is essentially a \textit{reachability} problem. We can state the following Theorem.

\begin{theorem}
A strong policy $\trace$ is a valid policy for $\D', \G'$ if and only if $\trace$ is a valid policy for $\D,\varphi$.
\end{theorem}

Given this Theorem, we can solve our original problem giving $\D'$ and $\P'$ as input to standard \FOND planners. The main state-of-art \FOND planners are:
\begin{itemize}
\item MBP and Gamer, which are OBDD\footnote{OBDD stands for \textit{Ordered Binary Decision Diagram}}-based planners \citep{cimatti2003weak, kissmann2009solving}
\item MyND and Grendel, which rely on explicit AND/OR graph search \citep{bercher2010pattern, ramirez2014directed}
\item PRP, NDP and FIP, which rely on classical algorithms \citep{kuter2008using, fu2011simple, muise2012improved}
\item FOND-SAT, which provides a SAT approach to \FOND planning \citep{geffner2018compact}
\end{itemize}
Although \FOND planning is receiving an increasingly interest, the research on computational approaches has been recently reduced. Nevertheless, some planners performs well on different contexts of use. In our thesis, we are going to employ a customized version of FOND-SAT, the newest planner.

Secondly, although the description of many real-world planning problems involves the use of conditional effects, requiring full support of ADL by planners, those state-of-art planners, cited above, are still not able to fully handle such conditional effects. This represents a big limitation that can be surely deepened as a future work of this thesis. To this extent, we should first compile away conditional effects from the domain and, then, we can give it to a planner. Our proposal implementation, thoroughly described in the Section \ref{sec:planning-implementation}, is able to compile away simple conditional effects, namely those conditional effects that do not have nested formulas. Additionally, we have to  compile away conditional effects of the \texttt{trans} operator upstream even though its  representation with the employment of conditional effects is much more effective and compact. Luckily, this process consists of just splitting the operator in as many operators as the number of conditional effects present in the original action and adding the condition formula in the preconditions for each conditional effect. In the following, we make a clarifying example.

\begin{example}
The \texttt{trans} operator built in the Example \ref{ex:new-dom} is:
\begin{lstlisting}[language=PDDL, escapechar=£]
(:action trans
  :parameters (?x - location)
  :precondition (not (turnDomain))
  :effect (and (when (and (q1 ?x) (not (vehicle-at ?x)))
              (and (q1 ?x) (not (q2 ?x)) (turnDomain))
          (when (or (and (q1 ?x) (vehicle-at ?x)) (q2 ?x))
              (and (q2 ?x) (not (q1 ?x)) (turnDomain))
  )
)
\end{lstlisting}
As we can see, it contains only two conditional effects. Hence, we split this operator in two operators that we are going to call \texttt{trans-0} and \texttt{trans-1}, respectively. In particular, for each conditional effect the condition formula is added to the precondition and the effect formula is left in the effects. \texttt{trans-0} and \texttt{trans-1} are as follows:
\begin{lstlisting}[language=PDDL, escapechar=£]
(:action trans-0
  :parameters (?x - location)
  :precondition (and (and (q1 ?x) (not (vehicle-at ?x))) 
    (not (turnDomain)))
  :effect (and (q1 ?x) (not (q2 ?x)) (turnDomain))
  )
)
(:action trans-1
  :parameters (?x - location)
  :precondition (and (or (and (q1 ?x) (vehicle-at ?x)) (q2 ?x)) 
    (not (turnDomain)))
  :effect (and (q2 ?x) (not (q1 ?x)) (turnDomain))
  )
)
\end{lstlisting}
\end{example}

At this point, having compiled away simple conditional effects from the modified domain $\D'$, we can finally describe how we have employed FOND-SAT in our thesis.

The main reasons why we have chosen FOND-SAT are the following:
\begin{itemize}
\item it is written in pure Python, hence we can easily integrate it in our Python implementation as we will see in Section \ref{sec:planning-implementation};
\item it performs reasonably well;
\item it outputs all policies building a transition system whose states are called \textit{controller states}.
\end{itemize}
FOND-SAT takes also advantage of the parser and translation PDDL-to-SAS+ scripts from  PRP. When FOND-SAT was developed, PRP's translation scripts could not handle disjunctive preconditions that may be present in our \texttt{trans} operators. As a result, we have modified FOND-SAT with the newest version of those scripts directly from PRP.

The usage of FOND-SAT is really simple. From its source folder, it is necessary to run the following command in the terminal:
\begin{lstlisting}[language=bash]
python main.py -strong 1 -policy 1 /path-to/domain.pddl 
/path-to/problem.pddl
\end{lstlisting}
The command simply executes the main module of FOND-SAT requiring to find strong policies and to print, if exists, the policy found. We feed FOND-SAT with our new domain $\D'$ and new problem $\P'$.

Once strong plans are found, FOND-SAT displays the policy in four sections as follows:
\begin{itemize}
\item Atom (CS): for each controller state it tells what predicates are true;
\item (CS, Action with arguments): for each controller state it tells which actions can be applied
\item (CS, Action name, CS): it tells for each controller state what action is applied in that state and the successor state;
\item (CS1, CS2): it means that the controller can go from CS1 to CS2. 
\end{itemize}
Now, we give an output example.

\begin{example}
The following result has been obtained running FOND-SAT with the Triangle Tireworld domain and problem with the \LTLf goal $\varphi = \Diamond vehicleAt(l31)$. What follows is only the displayed policy.
\begin{lstlisting}[numberstyle=\tiny\color{codegray}\noncopynumber,numbers=left,stepnumber=1, escapechar=£]
...
Trying with 7 states
Looking for strong plans: True
Fair actions: True
# Atoms: 18
# Actions: 26
SAT formula generation time = 0.052484
# Clauses = 11041
# Variables = 1225
Creating formula...
Done creating formula. Calling solver...
SAT solver called with 4096 MB and 3599 seconds
Done solver. Round time: 0.016456
Cumulated solver time: 0.055322
===================
===================
Controller -- CS = Controller State
===================
===================
Atom (CS)
___________________
----------
Atom q1(l31) (n0)
Atom vehicleat(l11) (n0)
Atom not-flattire() (n0)
Atom spare-in(l21) (n0)
Atom turndomain() (n0)
----------
-NegatedAtom turndomain() (n1)
Atom q1(l31) (n1)
Atom vehicleat(l21) (n1)
Atom not-flattire() (n1)
----------
Atom q1(l31) (n2)
-NegatedAtom turndomain() (n2)
Atom spare-in(l21) (n2)
Atom vehicleat(l21) (n2)
----------
Atom turndomain() (n3)
Atom q1(l31) (n3)
Atom vehicleat(l21) (n3)
Atom not-flattire() (n3)
----------
Atom q1(l31) (n4)
Atom spare-in(l21) (n4)
Atom vehicleat(l21) (n4)
Atom turndomain() (n4)
----------
Atom q1(l31) (n5)
Atom vehicleat(l31) (n5)
-NegatedAtom turndomain() (n5)
----------
Atom turndomain() (ng)
Atom q2(l31) (ng)
===================
===================
(CS, Action with arguments)£\label{line:cs-actarg}£
___________________
(n0,move-car_DETDUP_0(l11,l21))
(n0,move-car_DETDUP_1)
(n0,move-car_DETDUP_1(l11,l21))
(n0,move-car_DETDUP_0)
(n1,trans-0_v4)
(n1,trans-0_v4(l31))
(n2,trans-0_v4(l31))
(n2,trans-0_v4)
(n3,move-car_DETDUP_0(l21,l31))
(n3,move-car_DETDUP_0)
(n3,move-car_DETDUP_1(l21,l31))
(n3,move-car_DETDUP_1)
(n4,changetire(l21))
(n4,changetire)
(n5,trans-11)
(n5,trans-11(l31))
===================
===================
(CS, Action name, CS)
___________________
(n0,move-car_DETDUP_0,n1)£\label{line:cs-actarg}£
(n0,move-car_DETDUP_1,n2)
(n1,trans-0_v4,n3)
(n2,trans-0_v4,n4)
(n3,move-car_DETDUP_0,n5)
(n3,move-car_DETDUP_1,n5)
(n4,changetire,n1)
(n5,trans-11,ng)
===================
(CS, CS)
___________________
(n2,n4)
(n5,ng)
(n3,n5)
(n1,n3)
(n0,n2)
(n4,n1)
(n0,n1)
===================
Solved with 7 states
Elapsed total time (s): 0.288035
Elapsed solver time (s): 0.055322
Elapsed solver time (s): [0.0052, 0.0059, 0.007, 0.009, 0.011, 0.016]
Looking for strong plans: True
Fair actions: True
Done

\end{lstlisting}
As we can see, operators names are changed due to internal arrangements made by FOND-SAT needed to handle both non determinism and disjunctive preconditions. Here, it is important to observe that, as we expected, there is an alternation of action executions between the original domain actions and the \texttt{trans} operators. Finally, the transition system built by FOND-SAT has $n0$ as initial state and $ng$ as final state. If strong plans are found, it means that every path from $n0$ to $ng$ is a valid plan. We will better explain this later in Section \ref{sec:planning-results}.
\end{example}

In the following sections, we will describe in details our practical implementation, called \FONDFOR, that automates all the process illustrated in this Section.

\section{Implementation}\label{sec:planning-implementation}
In this section, we thoroughly describe the proposed implementation of concepts given in Section \ref{sec:fond-plan-appr}. In particular, we give some general information about its features, dependencies and usage. Then, we focus on the package explaining how is structured and commenting highlights on the code. 

We decided to call the package \FONDFOR, enhancing the possibility to solve \FOND planning also for \PLTL goals, which is a novelty in this area of research and application. Moreover, the package has been developed in pure Python and has the following main features:
\begin{itemize}
\item perform \FOND planning for \LTLf or \PLTL goals;
\item compiling simple ADL conditional effects from the planning domain;
\item encode \LTLf/\PLTL formulas into standard \PDDL \citep{mcdermott1998pddl}.
\end{itemize}
These features are achieved together with the integration of the \LTLfToDFA tool (Chapter \ref{ch:ltlf2dfa}).

Secondly, \FONDFOR requires Python>=3.6 and has the following dependencies:
\begin{itemize}
\item \LTLfToDFA, presented in Chapter \ref{ch:ltlf2dfa}. It has been used for the generation of \DFAs corresponding to \LTLf/\PLTL goal formulas;
\item \href{http://www.dabeaz.com/ply/ply.html}{PLY}, a pure-Python implementation of the popular compiler construction tools \href{http://dinosaur.compilertools.net/}{Lex and Yacc}. It has been employed for \PDDL parsing;
\item \href{https://pypi.org/project/pydot/}{pydot}, a Python interface to GraphViz format language. It has been employed for \DFAs parsing;
\item possible other dependencies linked to the employed planner. In the case of FOND-SAT, it has MINISAT as dependency.
\end{itemize} 
The \FONDFOR software is an open-source project and available to download on GitHub\footnote{https://github.com/Francesco17/FOND4LTLfPLTL}.

Additionally, \FONDFOR will soon be available as an online tool at the website address \href{http://fond4ltlfpltl.diag.uniroma1.it}{http://fond4ltlfpltl.diag.uniroma1.it}.
\subsection{Package Structure}
The structure of the \FONDFOR package is ordered and divided according to the scope of each single module. It consists of the following:
\begin{itemize}
\item \texttt{pddl/}: it is the directory containing all the necessary code for parsing the \PDDL standard and all data structures designed and implemented to handle \PDDL;
\item  \texttt{automa/}: it consists of the \texttt{automa.py} file, the \texttt{aparser.py} file and the \texttt{symbol.py} file. In this folder, we find all the code for dealing with automata;
\item \texttt{fond4ltlfpltl.py}: it is the main module of the package.
\end{itemize}
\subsection{\PDDL}\label{sec:impl-pddl}
In this section, we illustrate the code that handles the \PDDL standard. More specifically, we talk about the parsing of \PDDL domains and problems showing all implemented data structures.

First of all, thanks to the PLY library we have implemented the \texttt{lexer.py} and the \texttt{parser.py} modules enabling the parsing of a \PDDL document. For a brief overview of the functioning of PLY we refer the reader to Sections \ref{sec:lexer} and \ref{sec:parser}. Indeed, the operation is exactly the same. In the following, we show the listing of the two modules focusing only on the most important parts. Three dots $\dots$ represent omitted code.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-lexer}, caption={The \texttt{MyLexer} class.}]
import ply.lex as lex

class MyLexer(object):

    reserved = {
        'define':                   'DEFINE_KEY',
        'domain':                   'DOMAIN_KEY',
        ':domain':                  'DOMAIN_PKEY',
        ':requirements':            'REQUIREMENTS_KEY',
        ':constants':               'CONSTANTS_KEY',
        ':strips':                  'STRIPS_KEY',
        ':adl':                     'ADL_KEY',
        ':non-deterministic':       'ND_KEY',
        ':equality':                'EQUALITY_KEY',
        ':typing':                  'TYPING_KEY',
        ':types':                   'TYPES_KEY',
        ':predicates':              'PREDICATES_KEY',
        ':action':                  'ACTION_KEY',
        ':parameters':              'PARAMETERS_KEY',
        ':precondition':            'PRECONDITION_KEY',
        ':effect':                  'EFFECT_KEY',
        'and':                      'AND_KEY',
        'or':                       'OR_KEY',
        'not':                      'NOT_KEY',
        'imply':                    'IMPLY_KEY',
        'oneof':                    'ONEOF_KEY',
        'forall':                   'FORALL_KEY',
        'exists':                   'EXISTS_KEY',
        'when':                     'WHEN_KEY',
        'problem':                  'PROBLEM_KEY',
        ':objects':                 'OBJECTS_KEY',
        ':init':                    'INIT_KEY',
        ':goal':                    'GOAL_KEY'
    }

    tokens = (
         'NAME',
         'VARIABLE',
         'LPAREN',
         'RPAREN',
         'HYPHEN',
         'EQUALS'
    ) + tuple(reserved.values())

    t_LPAREN = r'\('
    t_RPAREN = r'\)'
    t_HYPHEN = r'\-'
    t_EQUALS = r'='

    t_ignore = ' \t'

    def t_KEYWORD(self, t):
        r':?[a-zA-z_][a-zA-Z_0-9\-]*'
        t.type = self.reserved.get(t.value,'NAME')
        return t

    def t_NAME(self, t):
        r'[0-9a-zA-z_][a-zA-Z_0-9\-]*'
        return t

    def t_VARIABLE(self, t):
        r'\?[a-zA-z_][a-zA-Z_0-9\-]*'
        return t

    def t_COMMENT(self, t):
        r';.*'
        pass
...
    def t_newline(self, t):
        r'\n+'
        t.lineno += len(t.value)
...
\end{lstlisting}
As we can see, we have defined all tokens present in \PDDL plus the \textit{oneof} keyword, which is used to parse also non deterministic actions. Then, we have specified all regular expression rules for those tokens.

On the other hand, following the official \PDDL standard grammar syntax, we have implemented the \texttt{MyParser} class as follows:

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-parser}, caption={The \texttt{MyParser} class.}]
...
class MyParser(object):
...

    def p_pddl(self, p):
        '''pddl : domain
                 | problem'''
        p[0] = p[1]

    def p_domain(self, p):
        '''domain : LPAREN DEFINE_KEY domain_def require_def types_def 
        constants_def predicates_def action_def_lst RPAREN
                   | LPAREN DEFINE_KEY domain_def require_def types_def 
                   predicates_def action_def_lst RPAREN
                   | LPAREN DEFINE_KEY domain_def require_def predicates_def 
                   action_def_lst RPAREN'''
        if len(p) == 10:
            p[0] = Domain(p[3], p[4], p[5], p[6], p[7], p[8])
        elif len(p) == 9:
            p[0] = Domain(p[3], p[4], p[5], [], p[6], p[7])
        else:
            p[0] = Domain(p[3], p[4], [], [], p[5], p[6])

    def p_problem(self, p):
        '''problem : LPAREN DEFINE_KEY problem_def domain_pdef objects_def 
        init_def goal_def RPAREN'''
        p[0] = Problem(p[3], p[4], p[5], p[6], p[7])
...
    def p_init_def(self, p):
        '''init_def : LPAREN INIT_KEY LPAREN AND_KEY ground_predicates_lst 
        RPAREN RPAREN
                     | LPAREN INIT_KEY ground_predicates_lst RPAREN'''
        if len(p) == 5:
            p[0] = p[3]
        elif len(p) == 8:
            p[0] = p[5]

    def p_goal_def(self, p):
        '''goal_def : LPAREN GOAL_KEY LPAREN AND_KEY ground_predicates_lst 
        RPAREN RPAREN
                     | LPAREN GOAL_KEY ground_predicates_lst RPAREN'''
        if len(p) == 7:
            p[0] = p[5]
        else:
            p[0] = p[3]
...
    def p_predicates_def(self, p):
        '''predicates_def : LPAREN PREDICATES_KEY predicate_def_lst RPAREN
        '''
        p[0] = p[3]
        
    def p_predicate_def(self, p):
        '''predicate_def : LPAREN NAME typed_variables_lst RPAREN
                           | LPAREN NAME RPAREN'''
        if len(p) == 4:
            p[0] = Predicate(p[2])
        elif len(p) == 5:
            p[0] = Predicate(p[2], p[3])
...
    def p_action_def(self, p):
        '''action_def : LPAREN ACTION_KEY NAME parameters_def precond_def 
        effects_def RPAREN'''
        p[0] = Action(p[3], p[4], p[5], p[6])

    def p_parameters_def(self, p):
        '''parameters_def : PARAMETERS_KEY LPAREN typed_variables_lst RPAREN
                            | PARAMETERS_KEY LPAREN RPAREN'''
        if len(p) == 4:
            p[0] = []
        elif len(p) == 5:
            p[0] = p[3]

    def p_precond_def(self, p):
        '''precond_def : PRECONDITION_KEY LPAREN formula RPAREN'''
        p[0] = p[3]

    def p_formula(self, p):
        '''formula : literal
                    | AND_KEY formula_lst
                    | OR_KEY formula_lst
                    | NOT_KEY formula
                    | IMPLY_KEY formula formula
                    | EXISTS_KEY LPAREN typed_variables_lst RPAREN formula
                    | FORALL_KEY LPAREN typed_variables_lst RPAREN formula
                    | LPAREN AND_KEY formula_lst RPAREN
                    | LPAREN OR_KEY formula_lst RPAREN
                    | LPAREN NOT_KEY formula RPAREN
                    | LPAREN IMPLY_KEY formula formula RPAREN
                    | LPAREN literal RPAREN
                    | LPAREN EXISTS_KEY LPAREN typed_variables_lst RPAREN 
                    formula RPAREN
                    | LPAREN FORALL_KEY LPAREN typed_variables_lst RPAREN 
                    formula RPAREN'''
        if len(p) == 2:
            p[0] = p[1]
        elif len(p) == 3:
            if p[1] == 'and':
                p[0] = FormulaAnd(p[2])
            elif p[1] == 'or':
                p[0] = FormulaOr(p[2])
            elif p[1] == 'not':
                p[0] = FormulaNot(p[2])
        elif len(p) == 4:
            if p[1] == 'imply':
                p[0] = FormulaImply(p[2], p[3])
            else:
                p[0] = p[2]
        elif len(p) == 5:
            if p[2] == 'and':
                p[0] = FormulaAnd(p[3])
            elif p[2] == 'or':
                p[0] = FormulaOr(p[3])
            elif p[2] == 'not':
                p[0] = FormulaNot(p[3])
        elif len(p) == 6:
            if p[3] == 'imply':
                p[0] = FormulaImply(p[3], p[4])
            elif p[1] == 'exists':
                p[0] = FormulaExists(p[3], p[5])
            elif p[1] == 'forall':
                p[0] = FormulaForall(p[3], p[5])
        elif len(p) == 8:
            if p[2] == 'exists':
                p[0] = FormulaExists(p[4], p[6])
            elif p[2] == 'forall':
                p[0] = FormulaForall(p[4], p[6])
...
    def p_effects_def(self, p):
        '''effects_def : EFFECT_KEY LPAREN one_eff_formula RPAREN'''
        if p[3] == 'and':
            p[0] = '(and)'
        else:
            p[0] = p[3]

    def p_one_eff_formula(self, p):
        '''one_eff_formula : literal
                             | AND_KEY one_eff_formula_lst
                             | AND_KEY
                             | ONEOF_KEY atomic_eff_lst
                             | WHEN_KEY formula atomic_eff
                             | LPAREN ONEOF_KEY atomic_eff_lst RPAREN
                             | LPAREN WHEN_KEY formula atomic_eff RPAREN
                             | LPAREN FORALL_KEY LPAREN typed_variables_lst 
                             RPAREN atomic_eff RPAREN
                             | LPAREN FORALL_KEY LPAREN typed_variables_lst 
                             RPAREN LPAREN WHEN_KEY formula atomic_eff 
                             RPAREN RPAREN'''
        if len(p) == 2:
            p[0] = p[1]
        elif len(p) == 3:
            if p[1] == 'and':
                p[0] = FormulaAnd(p[2])
            else: p[0] = FormulaOneOf(p[2])
        elif len(p) == 4:
            if p[1] == 'when':
                p[0] = FormulaWhen(p[2], p[3])
        elif len(p) == 5:
            p[0] = FormulaOneOf(p[3])
        elif len(p) == 6:
            p[0] = FormulaWhen(p[3], p[4])
        elif len(p) == 8:
            p[0] = FormulaForall(p[4], p[6])
        elif len(p) == 12:
            nested = FormulaWhen(p[8], p[9])
            p[0] = FormulaForall(p[4], nested)
...
    def p_atomic_eff(self, p):
        '''atomic_eff : literal
                      | AND_KEY literal_lst
                      | LPAREN AND_KEY literal_lst RPAREN
                      | LPAREN WHEN_KEY formula atomic_eff RPAREN'''
        if len(p) == 2:
            p[0] = p[1]
        elif len(p) == 3:
            if p[1] == 'and':
                p[0] = FormulaAnd(p[2])
        elif len(p) == 5:
            if p[2] == 'and':
                p[0] = FormulaAnd(p[3])
        elif len(p) == 6:
            p[0] = FormulaWhen(p[3], p[4])
...
    def p_literal(self, p):
        '''literal : LPAREN NOT_KEY predicate RPAREN
                    | predicate'''
        if len(p) == 2:
            p[0] = Literal.positive(p[1])
        elif len(p) == 5:
            p[0] = Literal.negative(p[3])

    def p_predicate(self, p):
        '''predicate : LPAREN NAME variables_lst RPAREN
                      | LPAREN EQUALS VARIABLE VARIABLE RPAREN
                      | LPAREN NAME RPAREN
                      | NAME variables_lst
                      | EQUALS VARIABLE VARIABLE
                      | NAME'''
        if len(p) == 2:
            p[0] = Predicate(p[1])
        elif len(p) == 3:
            p[0] = Predicate(p[1], p[2])
        elif len(p) == 4:
            if p[1] == '(':
                p[0] = Predicate(p[2])
            else:
                p[0] = Predicate('=', [p[2], p[3]])
        elif len(p) == 5:
            p[0] = Predicate(p[2], p[3])
        elif len(p) == 6:
            p[0] = Predicate('=', [p[3], p[4]])

    def p_typed_variables_lst(self, p):
        '''typed_variables_lst : variables_lst HYPHEN type 
        typed_variables_lst
                                 | variables_lst HYPHEN type'''
        if len(p) == 4:
            p[0] = [Term.variable(name, p[3]) for name in p[1]]
        else:
            p[0] = [Term.variable(name, p[3]) for name in p[1]] + p[4]

    def p_variables_lst(self, p):
        '''variables_lst : VARIABLE variables_lst
                         | VARIABLE'''
        if len(p) == 2:
            p[0] = [p[1]]
        elif len(p) == 3:
            p[0] = [p[1]] + p[2]
...
\end{lstlisting}
In Listing \ref{code:fond-parser}, there are all methods definition that are in charge of constructing the syntax tree structure from tokens found by the lexer in the input string document. Then, we have implemented a data structure for all components belonging to the \PDDL standard, starting from terms and predicates to the whole domain and problem. In this way, we provide a code more manageable and readable.

At this point, we are going to describe one after the other the implemented data structure of the main \PDDL components.

Firstly, variables and constants are represented by the \texttt{Term} class in Listing \ref{code:fond-term}.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-term}, caption={The \texttt{Term} class.}]
class Term:

    def __init__(self, **kwargs):
        self._name  = kwargs.get('name',  None)
        self._type  = kwargs.get('type',  None)
        self._value = kwargs.get('value', None)

    @property
    def name(self):
        return self._name

    @property
    def type(self):
        return self._type

    @property
    def value(self):
        return self._value
...
    @classmethod
    def variable(cls, name, type=None):
        return Term(name=name, type=type)

    @classmethod
    def constant(cls, value, type=None):
        return Term(value=value, type=type)

    def __str__(self):
        if self.is_variable() and self.is_typed():
            return '{0} - {1}'.format(self._name, self._type)
        if self.is_variable():
            return '{0}'.format(self._name)
        if self.is_constant() and self.is_typed():
            return '{0} - {1}'.format(self._value, self._type)
        if self.is_constant():
            return '{0}'.format(self._value)
\end{lstlisting}
A \texttt{Term} object is instantiated with three optional arguments: a name, a type and a value, respectively. As said before, a term can represent a variable or a constant. In each of these cases, it handles a possible typing and/or a possible value.

Secondly, we have the \texttt{Predicate} and the \texttt{Literal} classes. The former is used to represent \PDDL fluents, whereas the latter distinguishes between positive and negative fluents. Additionally, the \texttt{Predicate} class can also handle the equality predicates. In the following Listing we propose a glimpse of both the \texttt{Predicate} and the \texttt{Literal} classes.
\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-pred-lit}, caption={The \texttt{Predicate} and the \texttt{Literal} classes.}]
class Predicate:

    def __init__(self, name, args=[]):
        self._name = name
        self._args = args

    @property
    def name(self):
        return self._name

    @property
    def args(self):
        return self._args[:]
...
    def __str__(self):
        if self.name == '=':
            return '(= {0} {1})'.format(str(self._args[0]), 
            str(self._args[1]))
        elif self.arity == 0:
            return '('+self.name+')'
        else:
            return '({0} {1})'.format(self.name, ' '.join(map(str, 
            self._args)))
...

class Literal:

    def __init__(self, predicate, positiveness):
        self.predicate = predicate
        self.positiveness = positiveness
...
    @classmethod
    def positive(cls, predicate):
        return Literal(predicate, True)

    @classmethod
    def negative(cls, predicate):
        return Literal(predicate, False)

    def get_vars(self):
        return self.predicate.args

    def __str__(self):
        if self.is_positive():
            return str(self.predicate)
        if not self.is_positive() and self.predicate.name == '=':
            lhs = str(self.predicate.args[0])
            rhs = str(self.predicate.args[1])
            return '(not (= {0} {1}))'.format(lhs, rhs)
        if not self.is_positive():
            return '(not {})'.format(str(self.predicate))
\end{lstlisting}

After seeing the data structure for low level objects that we have just presented, we are going to illustrate the implementation of data structure for the rest, namely the \texttt{Action} class, the \texttt{Domain} class and, finally, the \texttt{Problem} class. Here, we skip the implementation of each formula since it simply consists of initializing and representing the corresponding object.

Firstly, we show main methods of the \texttt{Action} class in Listing \ref{code:fond-act}.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-act}, caption={The \texttt{Action} class.}]
from fond4ltlfpltl.PDDLparser.formula import FormulaAnd, FormulaOneOf
from fond4ltlfpltl.PDDLparser.literal import Literal
from fond4ltlfpltl.PDDLparser.predicate import Predicate

class Action:

    def __init__(self, name, parameters, preconditions, effects):
        self.name = name #string
        self.parameters = parameters #list
        self.preconditions = preconditions #formula.FormulaXXX
        self.effects = effects #formula.FormulaXXX

    def __str__(self):
        operator_str = '{0}\n'.format(self.name)
        operator_str += '\t:parameters ({0})\n'.format(' '.join(map(str, 
        self.parameters)))
        operator_str += '\t:precondition {0}\n'.format(self.preconditions)
        operator_str += '\t:effect {0}\n'.format(self.effects)
        return operator_str

    def add_to_precond(self):
        if isinstance(self.preconditions, FormulaAnd):
            self.preconditions.complete_domain_turn(True)
        else:
            old_formula = self.preconditions
            precond_to_be_added = Literal.positive(Predicate('turnDomain'))
            self.preconditions = FormulaAnd([old_formula,precond_to_be_added])

    def add_to_effect(self):
        if isinstance(self.effects, FormulaAnd):
            self.effects.complete_domain_turn(False)
        else:
            old_formula = self.effects
            effect_to_be_added = Literal.negative(Predicate('turnDomain'))
            self.effects = FormulaAnd([old_formula,effect_to_be_added])

    def add_turn_domain(self):£\label{line:add-turn-domain}£
        self.add_to_precond()
        self.add_to_effect()
\end{lstlisting}

As we can see from the Listing, the \texttt{Action} class contains all main properties, i.e. the name, parameters, preconditions and effects. Moreover, as done for all classes, the \texttt{Action} class has its string representation that convert the operator itself in \PDDL notation. As last remark, notice the \texttt{add\_turn\_domain} method which performs the addition to each operator (except from \texttt{trans} operators) of the domain of the new predicate \texttt{turnDomain}. In particular, we remind the reader that \texttt{turnDomain} is put positive in preconditions and negative on effects.

Secondly, we describe the two main data structures representing \PDDL elements: the \texttt{Domain} class and the \texttt{Problem} class, respectively. Both represent a complete planning task. In Listing \ref{code:fond-dom}, we can see the definition of the \texttt{Domain} class.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-dom}, caption={The \texttt{Domain} class.}]
from fond4ltlfpltl.PDDLparser.formula import *
from fond4ltlfpltl.PDDLparser.action import Action
import copy

class Domain:

    def __init__(self, name, requirements, types, constants, predicates, 
    operators):
        self.name = name #string
        self.requirements = requirements #list
        self.types = types #list
        self.constants = constants #list
        self.predicates = predicates #list
        self.operators = operators #list
...
    def add_operators_trans(self, transition_operators):
        for operator in transition_operators:
            self.operators.append(operator)

    def add_predicates(self, parameters, states):
        self.predicates.append('(turnDomain)')
        for state in states:
            self.predicates.append('(q{0} {1})'.format(str(state), 
            ' '.join(map(str, parameters))))
...
    def add_precond_effect(self):
        for op in self.operators:
            op.add_turn_domain()

    def get_new_domain(self, parameters, states, transition_operators):£\label{line:new-dom}£
        self.compile_simple_adl()
        self.add_predicates(parameters, states)
        self.add_precond_effect()
        self.add_operators_trans(transition_operators)
        return self

    def modify_operator(self, op_copy, condition, formula):
        if isinstance(op_copy.preconditions, FormulaAnd):
            op_copy.preconditions.andList.append(condition)
            new_preconditions = op_copy.preconditions.andList
            new_effects = formula
        else:
            new_preconditions = FormulaAnd([op_copy.preconditions,condition])
            new_effects = formula
        new_op = Action(op_copy.name, op_copy.parameters,
         new_preconditions, new_effects)
        return new_op

    def compile_simple_adl(self):£\label{line:compile-adl}£
        i = 0
        for op in self.operators:
            if isinstance(op.effects, FormulaWhen):
                # it remains only one operator, but we need to modify it
                condition_formula = op.effects.condition
                statement_formula = op.effects.formula
                new_op = self.modify_operator(copy.deepcopy(op),
                condition_formula, statement_formula)
                self.operators[i] = new_op
                continue
            elif isinstance(op.effects, FormulaAnd):
                no_of_whens = op.effects.count_whens()
                if no_of_whens == 0:
                    continue
                else:
                    pos = self.operators.index(op)
                    new_op_list = self.split_operator(copy.deepcopy(op),
                    no_of_whens)
                    self.operators[pos:pos+1] = new_op_list
            i +=1

    def split_operator(self, op, number):
        '''
        given a simple adl operator it returns
        a list of operators without adl
        '''
        new_op_list = []
        pair_precond_effect = []
        additionals = []
        formula = op.effects

        for item in formula.andList:
            if isinstance(item, FormulaWhen):
                formula_condition = item.condition
                formula_statement = item.formula
                pair_precond_effect.append([FormulaAnd([op.preconditions,
                formula_condition]), formula_statement])
            else:
                additionals.append(item)
        k = 1
        for j in range(len(pair_precond_effect)):
            pair_precond_effect[j][k] = FormulaAnd([pair_precond_effect[j]
            [k]]+additionals)

        for u in range(number):
            new_op = Action(op.name+'-'+str(u), op.parameters,
             pair_precond_effect[u][0], pair_precond_effect[u][1])
            new_op_list.append(new_op)

        return new_op_list
\end{lstlisting}
As seen in Section \ref{sec:pddl}, a \PDDL domain consists of a name,
the list of requirements, the list of types, the list of constants, the list of predicates and, finally, the list of operators. All items of these list, are instantiations of classes previously seen.
Regarding the \texttt{Domain} class, it comprises a couple of methods that contribute to the creation of the new domain in which we encode temporal goals. Additionally, at line \ref{line:compile-adl}, the class provides a method to compile away simple conditional effects in operators. This functionality simply splits operators containing conditional effects as many times as the number of conditional effects appearing in the action. More specifically, for each conditional effect we put the condition in action's preconditions and leave the effect-formula in the action's effect. Finally, we have the \texttt{get\_new\_domain} method, at line \ref{line:new-dom}, that gathers and invokes all methods for obtaining the new domain with encoded temporal goals.

Finally, we present the \texttt{Problem} class in Listing \ref{code:fond-prob}.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-prob}, caption={The \texttt{Problem} class.}]
from fond4ltlfpltl.PDDLparser.formula import FormulaOr

class Problem(object):

    new_goal = set()

    def __init__(self, name, domain, objects, init, goal):
        self._name = name
        self._domain = domain
        self._objects = {}
        for obj in objects:
            self._objects[obj.type] = self._objects.get(obj.type, [])
            self._objects[obj.type].append(str(obj.value))
        self._init = set(map(str, init))
        self._goal = set(map(str, goal))

    @property
    def name(self):
        return self._name

    @property
    def domain(self):
        return self._domain

    @property
    def objects(self):
        return self._objects.copy()

    @property
    def init(self):
        return self._init.copy()

    @property
    def goal(self):
        return self._goal.copy()

    def __str__(self):
        problem_str  = '(define (problem {0})\n'.format(self._name)
        problem_str += '\t(:domain {0})\n'.format(self._domain)
        problem_str += '\t(:objects'
        for type, objects in self._objects.items():
            problem_str += ' {0} - {1}'.format(' '.join(sorted(objects)), 
            type)
        problem_str += ')\n'
        problem_str += '\t(:init {0})\n'.format(' '.join(sorted(
        self._init)))
        problem_str += '(:goal (and {0}))\n'.format(
        ' '.join(sorted(self.new_goal)))
        problem_str += ')'
        return problem_str

    def make_new_init(self, obj_list):£\label{line:new-init}£
        self._init.add('(turnDomain)')
        if obj_list:
            self._init.add('(q1 {0})'.format(' '.join(obj_list)))
        else:
            self._init.add('(q1)')
        return self._init

    def make_new_goal(self, final_states, obj_list):£\label{line:new-goal}£
        self.new_goal.add('(turnDomain)')
        if len(final_states) > 1:
            or_list = []
            for state in final_states:
                if obj_list:
                    or_list.append('(q{0} {1})'.format(str(state), 
                    ' '.join(obj_list)))
                else:
                    or_list.append('(q{0})'.format(str(state)))
            new_formula = FormulaOr(or_list)
            self.new_goal.add(str(new_formula))
        else:
            if obj_list:
                self.new_goal.add('(q{0} {1})'.format(final_states[0], 
                ' '.join(obj_list)))
            else:
                self.new_goal.add('(q{0})'.format(final_states[0]))

    def get_new_problem(self, final_states, symbols_list):£\label{line:new-prob}£
        obj_list = self.extract_object_list(symbols_list)
        self.objects_are_upper(obj_list)
        self.make_new_init(obj_list)
        self.make_new_goal(final_states, obj_list)
        return self

    def extract_object_list(self, symbols_list):
        already_seen = set()
        obj_list = []
        for symbol in symbols_list:
            if symbol.objects:
                for obj in symbol.objects:
                    if obj not in already_seen:
                        already_seen.add(obj)
                        obj_list.append(obj)
                    else:
                        pass
            else:
                continue
        return obj_list

    def objects_are_upper(self, objects):
        for value_list in self.objects.values():
            for val in value_list:
                if val.isupper() and val.lower() in objects:
                    objects[objects.index(val.lower())] = 
                    objects[objects.index(val.lower())].upper()
                else:
                    pass
\end{lstlisting}
The main methods are:
\begin{itemize}
\item \texttt{make\_new\_init} (line \ref{line:new-init});
\item \texttt{make\_new\_goal} (line \ref{line:new-goal});
\item \texttt{get\_new\_problem} (line \ref{line:new-prob}).
\end{itemize}
Having the informations about the \DFA encoding, the first method computes the new initial specification by adding the \texttt{turnDomain} predicates and the initial state predicate of the automaton. Likewise, the second method assembles the new goal specification accordingly with the theory illustrated in Section \ref{sec:encoding-goals}. Finally, the third method simply returns the new problem encoded in standard \PDDL.

\subsection{Automa}\label{sec:impl-automa}
In this section, we illustrate the code that handles extended temporal goals treated as automata. More specifically, we talk about the generation of \DFA corresponding to the \LTLf/\PLTL goal, the parsing and managing of such generated \DFA showing all implemented data structures.

First of all, as stated before, given an \LTLf/\PLTL goal formula, we employ the \LTLfToDFA tool to generate the \DFA. Secondly, as soon as the \DFA is generated, we parse it with the \texttt{aparser.py} module and then, we instantiate an \texttt{Automa} object for it. In the following, we will discuss more about the \texttt{Automa} class, since the \texttt{aparser.py} module is pretty much the same discussed in Section \ref{sec:janus-impl-automa}.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-automa}, caption={The \texttt{Automa} class.}]
...
class Automa:
    def __init__(self, alphabet, states, initial_state, accepting_states,
     transitions):
        self.alphabet = alphabet
        self.states = states
        self.initial_state = initial_state
        self.accepting_states = accepting_states
        self.transitions = transitions
        self.trans_by_dest = self.group_conditions_by_consequence()£\label{line:trans-by-dest}£
        self.validate()
...
    def validate(self):
        self.validate_initial_state()
        self.validate_accepting_states()
        self.valide_transition_start_states()
        self.validate_input_symbols()
        return True

    def __str__(self):
        automa = 'alphabet: {}\n'.format(str(self.alphabet))
        automa += 'states: {}\n'.format(str(self.states))
        automa += 'init_state: {}\n'.format(str(self.initial_state))
        automa += 'accepting_states: {}\n'.format(str(self.accepting_states))
        automa += 'transitions: {}'.format(str(self.transitions))
        return automa

    def create_operators_trans(self, domain_predicates,£\label{line:op-trans}£ grounded_symbols):
        new_operators = []
        my_predicates = []
        for symbol in grounded_symbols:
            my_predicates.append(symbol.name)
        (parameters, obj_mapping) = £\label{line:trans-param}£ self.compute_parameters(domain_predicates, 
        grounded_symbols)
        vars_mapping = self.compute_varsMapping(grounded_symbols,£\label{line:trans-vars-map}£
         obj_mapping)
        my_variables = self.compute_variables(parameters)
        counter = 0
        for destination, source_action in self.trans_by_dest.items():£\label{line:trans-prec-eff}£
            if source_action:
                fluents_list_precond = self.compute_preconditions(source_action,
                 vars_mapping, my_predicates, my_variables)
                if isinstance(fluents_list_precond, FormulaAnd):
                    new_precondition = fluents_list_precond
                else:
                    new_precondition = FormulaAnd([fluents_list_precond] 
                    + [Literal.negative(Predicate('turnDomain'))])
                new_effects = self.compute_effects(destination, my_variables)
                new_operators.append(Action('trans-'+str(counter),
                 parameters, new_precondition, new_effects))
            else:
                pass
            counter += 1
        return (new_operators, parameters)

    def compute_type(self, all_predicates, name, position):
        for predicate in all_predicates:
            if predicate.name == name:
                if predicate.args:
                    return (predicate.args[position].name +
                     ''.join(random.choices(string.digits, k=2)),
                      predicate.args[position].type)
                else:
                    raise ValueError('[ERROR]: Please check the formula')
            else:
                pass

    def compute_parameters(self,domain_predicates, grounded_symbols):
        objs_set = set()
        obj_mapping = {}
        parameters = []
        for symbol in grounded_symbols:
            if symbol.objects:
                i = 0
                for obj in symbol.objects:
                    if obj not in objs_set:
                        objs_set.add(obj)
                        (name_var, type_) = self.compute_type(domain_predicates, 
                        symbol.name, i)
                        obj_mapping[obj] = [name_var, type_]
                        parameters.append(Term.variable(name_var, type_))
                    else:
                        pass
                    i += 1
        return (parameters, obj_mapping)

    def compute_varsMapping(self, grounded_symbols, obj_mapping):
        temp = []
        vars_mapping = {}
        for symbol in grounded_symbols:
            if symbol.objects:
                for obj in symbol.objects:
                    temp.append((obj_mapping[obj][0], obj_mapping[obj][1]))
            else:
                vars_mapping[symbol] = []
            vars_mapping[symbol] = temp
            temp = []
        return vars_mapping

    def compute_preconditions(self, source_action, vars_mapping,
     predicates_name, variables):
        if len(source_action) == 1:
            if self.get_automaton_formula(vars_mapping, predicates_name,
             source_action[0][1]) == []:
                formula = Literal.positive(Predicate('q'+
                str(source_action[0][0]), variables))
            else:
                automaton_state = [Literal.positive(Predicate('q'+
                str(source_action[0][0]), variables))]
                formula = FormulaAnd(automaton_state+
                self.get_automaton_formula(vars_mapping, predicates_name,
                 source_action[0][1])+[Literal.negative(Predicate('turnDomain'))])
        else:
            formula = FormulaOr(self.get_or_conditions(vars_mapping,
             predicates_name, variables, source_action))
        return formula

    def compute_effects(self, destination, variables):
        negated_states = []
        for state in self.states:
            if state != destination:
                negated_states.append(Literal.negative(Predicate('q'+
                str(state), variables)))
            else:
                pass
        automaton_destination = [Literal.positive(Predicate('q'+
        str(destination), variables))]
        turnDomain = [Literal.positive(Predicate('turnDomain'))]
        formula = FormulaAnd(automaton_destination+negated_states+turnDomain)
        return formula

    def get_or_conditions(self, vars_mapping, predicates_name, variables,
     source_action_list):
        items = []
        for source, action in source_action_list:
            formula = self.get_automaton_formula(vars_mapping,
             predicates_name, action)
            if formula == []:
                items.append(Literal.positive(Predicate('q'+str(source),
                 variables)))
            else:
                automaton_state = [Literal.positive(Predicate('q'+
                str(source), variables))]
                items.append(FormulaAnd(automaton_state+
                self.get_automaton_formula(vars_mapping, predicates_name, 
                action)))
        return items

    def get_automaton_formula(self, vars_mapping, predicates_name, action):
        temp = []
        i = 0
        for char in action:
            if char == '1':
 list(vars_mapping)]:
                temp.append(Literal.positive(Predicate(predicates_name[i],
                 [x[0] for x in vars_mapping[list(vars_mapping)[i]]] )))
 temp.append(Literal.positive(Predicate(predicates_name[i])))
            elif char == '0':
                temp.append(Literal.negative(Predicate(predicates_name[i],
                 [x[0] for x in vars_mapping[list(vars_mapping)[i]]] )))
 temp.append(Literal.negative(Predicate(predicates_name[i])))
            else:
                pass
            i += 1
        return temp

    def compute_variables(self, parameters_list):
        my_variables = []
        for param in parameters_list:
            my_variables.append(param.name)
        return my_variables

    def create_dict_by_destination(self):
        trans_by_dest = {}
        for state in self.states:
            trans_by_dest[state] = []
        return trans_by_dest

    def group_conditions_by_consequence(self):
        group_by_dest = self.create_dict_by_destination()
        for source, trans in self.transitions.items():
            i = 0
            for dest in trans.values():
                group_by_dest[dest].append((source, list(trans.keys())[i]))
                i +=1
        return group_by_dest
\end{lstlisting}
In Listing \ref{code:fond-automa}, we have the main data structure representing the \DFA generated by \LTLfToDFA. As soon as an object is instantiated, transitions are grouped by destination state by a method at line \ref{line:trans-by-dest}. This operation is useful to get a compact representation of each \texttt{trans} operator created. We recall that, the \texttt{trans} operator, created in Section \ref{sec:encoding-goals}, is then split in multiple \texttt{trans} operators because not all planners support conditional effects.

The main method of the \texttt{Automa} class is obviously the \texttt{create\_operators\_trans} which gather all other methods. It takes as input the domain predicates and the grounded symbols of the goal formula. Moreover, the method consists of the operations explained theoretically. In particular, we have:
\begin{itemize}
\item it computes all parameters involved by the grounded symbols of the formula, at line \ref{line:trans-param}, using the \texttt{compute\_parameters} method;
\item it implements the function $f$, defined in \ref{plan:mapfunc}, mapping objects to variables at line \ref{line:trans-vars-map};
\item it computes variables;
\item at line \ref{line:trans-prec-eff}, it builds preconditions and effects for each transition of the \DFA;
\item for each \texttt{trans} operator created, it is added to a the list of trans operators.
\end{itemize}

In the next Section, we will see the main module, which implements all the high level procedure illustrated previously in Section \ref{sec:fond-plan-appr}.
\subsection{Main Module}
Here, we describe the main module of the \FONDFOR package. It is called \texttt{fond4ltlfpltl.py} and it contains the principal logic covering the \FONDFOR theoretical approach illustrated in Section \ref{sec:fond-plan-appr}. In Listing \ref{code:fond-main}, we show the implementation.

\begin{lstlisting}[language=Python, style=Python, escapechar = £,  label={code:fond-main}, caption={The \texttt{fond4ltlfpltl.py} module.}]
from fond4ltlfpltl.PDDLparser.parser import MyParser
from ltlf2dfa.Translator import Translator
from ltlf2dfa.DotHandler import DotHandler
from fond4ltlfpltl.AutomaParser.symbol import Symbol
from fond4ltlfpltl.AutomaParser.aparser import parse_dot
import argparse, os, subprocess, copy, re

args_parser = argparse.ArgumentParser(...)£\label{line:main-argparser}£

params = vars(args_parser.parse_args())
pddl_parser = MyParser()

try:
    with open(params['<planning_domain>'], 'r') as f:
        domain = f.read()
        f.close()
    parsed_domain = pddl_parser(domain)£\label{line:main-parse-dom}£
except:
    raise ValueError('[ERROR]: Could not parse domain')

try:
    with open(params['<planning_problem>'], 'r') as f:
        problem = f.read()
        f.close()
    parsed_problem = pddl_parser(problem)£\label{line:main-parse-prob}£
except:
    raise ValueError('[ERROR]: Could not parse problem')
...
try:
    translator = Translator(params['<goal_formula>'])£\label{line:main-dfa}£
    translator.formula_parser()
    translator.translate()
    translator.createMonafile(False)
    translator.invoke_mona()
    dot_handler = DotHandler()
    dot_handler.modify_dot()
    dot_handler.output_dot()
    dfa_automaton = parse_dot("automa.dot")
    operators_trans, parameters = dfa_automaton.create_operators_trans(...)£\label{line:main-transs}£
    os.remove('automa.mona')
    os.remove('automa.dot')
except:
    os.remove('automa.mona')
    os.remove('automa.dot')
    raise ValueError('[ERROR]: Could not create DFA')

old_domain = copy.deepcopy(parsed_domain)

new_domain = parsed_domain.get_new_domain(...)£\label{line:main-new-dom}£
new_problem = parsed_problem.get_new_problem(...)£\label{line:main-new-prob}£

try:
    with open("./new-dom.pddl", 'w+') as dom:
        dom.write(str(new_domain))
        dom.close()
    with open("./new-prob.pddl", 'w+') as prob:
        prob.write(str(new_problem))
        prob.close()
except:
    raise IOError('[ERROR]: Something wrong occurred')
    
...    
\end{lstlisting}
To begin with, the main module accepts as input a \PDDL domain, a \PDDL problem and a goal formula. All these arguments are handled by the argument parser at line \ref{line:main-argparser}.

After gathered all inputs, we proceed by parsing both the \PDDL domain and the \PDDL problem (lines \ref{line:main-parse-dom} and \ref{line:main-parse-prob}). The parsing phase is carried out by module illustrated in Section \ref{sec:impl-pddl}.

Then, we translate the \LTLf/\PLTL goal formula into the corresponding \DFA employing \LTLfToDFA. The code that is in charge of doing that starts at line \ref{line:main-dfa}. Once the \DFA is built, we can construct the new \texttt{trans} operator at line \ref{line:main-transs}.

Consequently, we put all things together and we create the new domain $\D'$ and the problem $\P'$ (lines \ref{line:main-new-dom} and \ref{line:main-new-prob}). Finally, we invoke the FOND-SAT planner feeding it with $\D'$ and $\P'$. If a strong plan is found we obtain it in a file on the working directory.

\section{Results}\label{sec:planning-results}
In this Section, we show an execution of the \FONDFOR tool as example of result. In particular, we show an execution involving a \PLTL goal. We go step-by-step through the solution and we pay  attention to the \texttt{trans} operator.

We remind the reader that \FONDS planning for \PLTL goals is interpreted as reaching a final state such that the history leading to such a state satisfies the given \PLTL formula.
For instance, here we show an execution of the \FONDFOR tool on the Triangle Tireworld planning task partly illustrated in Example \ref{ex:new-dom}. Indeed, the original domain is the same of the one in Example \ref{ex:new-dom} whereas the original initial state is as follows:
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (problem triangle-tire-1)
  (:domain triangle-tire)
  (:objects l11 l12 l13 l21 l22 l23 l31 l32 l33 - location)
  (:init (vehicle-at l11)
    (road l11 l12) (road l12 l13) (road l11 l21) (road l12 l22)
    (road l21 l12) (road l22 l13) (road l21 l31) (road l31 l22)
    (spare-in l21) (spare-in l22) (spare-in l31)
    (not-flattire))
  (:goal (vehicle-at l13))
)
\end{lstlisting}
In this case, we choose the \PLTL goal formula $\varphi = vehicleAt(l13) \lAND \Once(vehicleAt(l23))$. Such a formula means \emph{reach location l13 passing through location l23 at least once}. The \DFA corresponding to $\varphi$, generated with \LTLfToDFA, is depicted in Figure \ref{fig:dfa-result-pltl}.

\begin{figure}[h]
\centering
\includegraphics[width=0.58\textwidth]{images/automa-param3}
\caption{The \DFA corresponding to $\varphi$} 
\label{fig:dfa-result-pltl}
\end{figure}

After the execution of \FONDFOR, we obtain the following:
\begin{enumerate}
\item a new planning domain;
\item a new planning problem;
\item a transition system showing all policies, if found.
\end{enumerate}
Firstly, the new domain $\D'$ is:
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (domain triangle-tire)
  (:requirements :typing :strips :non-deterministic)
  (:types location)
  (:predicates (vehicleat ?loc - location) (spare-in ?loc - location) 
  (road ?from - location ?to - location) (not-flattire) (turnDomain) 
  (q2 ?loc30 - location ?loc53 - location) 
  (q1 ?loc30 - location ?loc53 - location) 
  (q3 ?loc30 - location ?loc53 - location))
  (:action move-car
    :parameters (?from - location ?to - location)
    :precondition (and (vehicleat ?from) (road ?from ?to) 
    (not-flattire) (turnDomain))
    :effect (and (oneof (and (vehicleat ?to) 
    (not (vehicleat ?from))) (and (vehicleat ?to) 
    (not (vehicleat ?from)) (not (not-flattire)))) 
    (not (turnDomain)))
  )
  (:action changetire
    :parameters (?loc - location)
    :precondition (and (spare-in ?loc) (vehicleat ?loc) 
    (turnDomain))
    :effect (and (not (spare-in ?loc)) (not-flattire) 
    (not (turnDomain)))
  )
  (:action trans-0
    :parameters (?loc30 - location ?loc53 - location)
    :precondition (and (or (and (q1 ?loc30 ?loc53) 
    (not (vehicleat ?loc30)) (vehicleat ?loc53)) 
    (and (q2 ?loc30 ?loc53) (not (vehicleat ?loc30))) 
    (and (q3 ?loc30 ?loc53) (not (vehicleat ?loc30)))) 
    (not (turnDomain)))
    :effect (and (q2 ?loc30 ?loc53) 
    (not (q1 ?loc30 ?loc53)) (not (q3 ?loc30 ?loc53)) 
    (turnDomain))
  )
  (:action trans-1
    :parameters (?loc30 - location ?loc53 - location)
    :precondition (and (or (and (q1 ?loc30 ?loc53) 
    (not (vehicleat ?loc30)) (not (vehicleat ?loc53))) 
    (and (q1 ?loc30 ?loc53) (vehicleat ?loc30) 
    (not (vehicleat ?loc53)))) (not (turnDomain)))
    :effect (and (q1 ?loc30 ?loc53) 
    (not (q2 ?loc30 ?loc53)) (not (q3 ?loc30 ?loc53)) 
    (turnDomain))
  )
  (:action trans-2
    :parameters (?loc30 - location ?loc53 - location)
    :precondition (and (or (and (q1 ?loc30 ?loc53) 
    (vehicleat ?loc30) (vehicleat ?loc53)) 
    (and (q2 ?loc30 ?loc53) (vehicleat ?loc30)) 
    (and (q3 ?loc30 ?loc53) (vehicleat ?loc30))) 
    (not (turnDomain)))
    :effect (and (q3 ?loc30 ?loc53) 
    (not (q2 ?loc30 ?loc53)) (not (q1 ?loc30 ?loc53)) 
    (turnDomain))
  )
)
\end{lstlisting}

Secondly, the new problem $\P'$ is:
\begin{lstlisting}[language=PDDL, escapechar=£]
(define (problem triangle-tire-1)
	(:domain triangle-tire)
	(:objects l11 l12 l13 l21 l22 l23 l31 l32 l33 - location)
	(:init (not-flattire) (q1 l13 l23) (road l11 l12) (road l11 l21) 
	(road l12 l13) (road l12 l22) (road l21 l12) (road l21 l31) 
	(road l22 l13) (road l22 l23) (road l23 l13) (road l31 l22) 
	(spare-in l21) (spare-in l22) (spare-in l23) (spare-in l31)
	(turnDomain) (vehicleat l11))
(:goal (and (q3 l13 l23) (turnDomain)))
)
\end{lstlisting}

Finally, feeding FOND-SAT with $\D'$ and $\P'$ we obtain the following transition system depicted in Figure \ref{fig:policy-trans}, thanks to another Python script, developed in this thesis, for converting a written policy into a graph.

\begin{figure}[h]
\centering
\includegraphics[]{images/graph-policy-trans1}
\caption{The transition system showing policies found with the \texttt{trans} operator} 
\label{fig:policy-trans}
\end{figure}

A plan is whatever path from $n0$ leading to state $ng$. 
Moreover, as we can see from Figure \ref{fig:policy-trans}, there is a perfect alternation between domain's actions and the \texttt{trans} action. Additionally, the above-mentioned script could also remove transitions involving the \texttt{trans} action getting the final plan. We can see it in Figure \ref{fig:policy-no-trans}.

\begin{figure}[h]
\centering
\includegraphics[]{images/graph-policy1}
\caption{The transition system showing policies found without the \texttt{trans} operator} 
\label{fig:policy-no-trans}
\end{figure}

\section{Summary}
In this chapter, we have faced the problem of \FOND Planning for \LTLf/\PLTL goals. In particular, we have proposed a new solution, called \FONDFOR, that essentially reduces the problem to a ``classical'' \FOND planning problem. This has been possible thanks to our \LTLfToDFA Python tool which has been employed for the encoding of temporally extended goals into standard \PDDL. Then, we have also described in details the \FONDFOR implementation, highlighting all its main features. Finally, we have seen examples of execution results.

